<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Algebraic Effects and Handlers - Javascript</title>
    
    <link rel="stylesheet" type="text/css" href="examples.css">
    
    <!--script id='eff' type="text/javascript" src="Effects.js"></script>
    <script id='eff' type="text/javascript" src="EffectTest.js"></script-->
    <script type="text/javascript" src="../tailspin.js"></script>
    
    <script src="lib/codemirror.js"></script>
    <link rel="stylesheet" href="lib/codemirror.css">
    <style type="text/css">
      .breakpoints {width: .8em;}
      .breakpoint { color: #822; }
      .CodeMirror {border: 1px solid #aaa;}
    </style>
    <script src="lib/terminal/js/jquery-1.7.1.min.js"></script>
    <script src="lib/terminal/js/jquery.mousewheel-min.js"></script>
    <script src="lib/terminal/js/jquery.terminal-min.js"></script>
    <link rel="stylesheet" href="lib/terminal/css/jquery.terminal.css">
    <script type="text/javascript">
        var terminal
        var evaluateInContext = function (cmd) {
            if (undefined != cmd) terminal.echo("Not running");
        }
        function initTerm(term) {
            terminal = term;
        }
        var interpreter;
        var tailspinDebugger;
        var mySource, myConsole;
        var breakpoint = {}
        
        window.onload = function() {
            // Create a new interpreter.
            interpreter = new Tailspin.Interpreter();
            tailspinDebugger = new Debugger();
            
            // Add a single global 'console' that has a log function.
            interpreter.global.console = {
                log:function(msg) {consoleLog(msg, 'log');}
            };
            
            mySource = CodeMirror.fromTextArea(document.getElementById("source"),
                            {lineNumbers:true, mode:"javascript",
                             gutters: ["CodeMirror-linenumbers", "breakpoints"]});

            mySource.on("gutterClick", function(cm, n) {
                    var info = cm.lineInfo(n);
                    breakpoint[n] = info.gutterMarkers == null;
                    cm.setGutterMarker(n, "breakpoints", !breakpoint[n] ? null : makeMarker());
                });
            
            function makeMarker() {
                var marker = document.createElement("div");
                marker.style.color = "#822";
                marker.innerHTML = "â—";
                return marker;
            }
            
            var sourcecode = document.getElementById('sourcecode');
            var source = sourcecode.textContent;
            mySource.setValue(source);
            jQuery(function($, undefined) {
                    $('#console').terminal(function(command, term) {
                            initTerm(term);
                            evaluateInContext(command);
                        }, {
                            greetings: 'Evaluate:',
                                name: 'js_demo',
                                height: '28%',
                                history: true,
                                onInit: initTerm,
                                prompt: 'js> '});
                });
            
            
            // Save the code on changes.
            mySource.on('change', function(cMirror) {
                    localStorage["debugger-source"] = cMirror.getValue();
                });
            // Load saved code.
            var savedScript = localStorage["debugger-source"];
            if (typeof savedScript === "string") {
                //mySource.setValue(savedScript);
            }
        }
        function consoleLog(msg, logClass) {
            if ('error' == logClass) { terminal.error(msg) } else { terminal.echo(msg) }
        }
        
        function Debugger() {
            
            this.state = "stopped";
            this.currentLine = -1;
            this.continuation = null;
            this.highlightedLine = -1;
            
            this.runButton = document.getElementById("run-button");
            this.stopButton = document.getElementById("stop-button");
            this.pauseButton = document.getElementById("pause-button");
            this.stepIntoButton = document.getElementById("step-into-button");
            this.stepOverButton = document.getElementById("step-over-button");
            this.stepOutButton = document.getElementById("step-out-button");
            this.todo = [];
            this.updateButtons();
            this.callStackSize = 0;
            this.inFlush = 0;
        }
        
        Debugger.prototype = {
            flush: function() {
                var stopped = (this.state === "paused" || this.state === "stopped");
                while (!stopped && this.todo.length > 0) {
                    var current = this.todo;
                    this.todo = [];
                    for (var i = 0; i < current.length; i++) {
                        current[i]();
                    }
                    stopped = (this.state === "paused" || this.state === "stopped");
                }
            },
            updateButtons: function() {
                var running = (this.state === "paused" || this.state === "stopped");
                this.runButton.disabled = !running;
                this.stopButton.disabled = this.state === "stopped";
                this.pauseButton.disabled = running;
                this.stepIntoButton.disabled = !running; // Can start by stepping over or into.
                this.stepOverButton.disabled = !running;
                this.stepOutButton.disabled = this.state !== "paused";
            },
            end: function(output, outputClass) {
                if (output) {
                    consoleLog(String(output), outputClass);
                }
                this.state = "stopped";
                this.todo = [];
                this.continuation = null;
                mySource.removeLineClass(this.highlightedLine, 'background', 'current-line');
                this.updateButtons();
            },
            returnFn: function(result) {
                consoleLog(JSON.stringify(result), "output");
                this.end();
            },
            errorFn: function(result) {
                if (result == "end-of-continuation") return;
                this.end("Line "+result.sourceLine +": "+result.message, "error");
            },
            start: function() {
                // Create an evaluation context that describes the how the code is to be executed.
                var x = interpreter.createExecutionContext();
                this.todo = [];
                x.asynchronous = false;
                x.control = this.control.bind(this);
                this.x = x;
                this.currentLine = -1;
                this.stackDepth = 0;
                this.currentScope = x;
                var dbg = this;
                evaluateInContext = function(command) {
                            try {
                                var cx = dbg.currentScope.copy();
                                cx.asynchronous = false;
                                var isDone = false;
                                cx.control = function(n, x, next, prev) {
                                    if(!isDone) next(prev)
                                }
                                interpreter.evaluateInContext(command, "", 0, cx, function(result) {
                                      if (undefined != result) terminal.echo(String(result)); isDone = true;
                                 }, function(err) { 
                                      terminal.error(String(err)); isDone = true;
                                }, null)
                            } catch(e) {
                                terminal.error("internal debugger error: "+new String(e));
                            }
                }
                this.updateButtons();
                
                // Run the code.
                var source = mySource.getValue();
                try {
                    interpreter.evaluateInContext(source, "source", 0, x, this.returnFn.bind(this), this.errorFn.bind(this), null);
                } catch (e) {
                    term.error("internal debugger error: "+new String(e));
                }
                this.flush();
            },
            continueWithState: function(state) {
                this.state = state;
                if (this.continuation) {
                    this.continuation();
                }
                else {
                    this.start();
                }
            },
            run: function() {
                this.continueWithState("running");
            },
            stepInto: function() {
                this.continueWithState("step-into");
            },
            stepOver: function() {
                this.continueWithState("step-over");
            },
            stepOut: function() {
                this.continueWithState("step-out");
            },
            stepBack: function() {
                this.continuation = this.backContinuation;
                this.backContinuation = null;
                this.continueWithState("step-back");
            },
            pause: function() {
                this.state = "paused";
            },
            stop: function() {
                this.todo = [];
                this.continuation = null;
                this.state = "stopped";
                this.end();
            },
            
            doPause: function(n, x, next, prev) {
                this.state = "paused";
                this.currentLine = n.lineno;
                this.stackDepth = x.stack.length;
                this.todo.push(function() { next(prev) });
                // Save a continuation which will continue the execution of the code.
                this.continuation = function() {
                    this.updateButtons();
                    mySource.removeLineClass(this.highlightedLine, 'background', 'current-line');
                    this.flush();
                  }.bind(this);
                // Save a continuation which will continue the execution of the code.
                this.backContinuation = !prev ? null: function() {
                    this.updateButtons();
                    mySource.removeLineClass(this.highlightedLine, 'background', 'current-line');
                    if (prev) prev();
                  }.bind(this);
                mySource.removeLineClass(this.highlightedLine, 'background', 'current-line');
                // Highlight the new line.
                this.highlightedLine = n.lineno-1;
                mySource.addLineClass(this.highlightedLine, 'background', 'current-line');
                var info = mySource.getScrollInfo();
                var top = info.top;
                var bot = top + info.clientHeight;
                var lineHeight = info.height / mySource.lineCount();
                var vpos = this.highlightedLine * lineHeight;
                var margin = 0;
                if (vpos < top + lineHeight*2 || vpos > bot - lineHeight*2) {
                    margin = 80;
                    mySource.scrollIntoView({line: this.highlightedLine}, 80);
                }
                this.updateButtons();
            },
            
        control: function(n, x, next, prev) {
                var self = this;
                this.currentScope = x;
                function resume(now) {
                    self.flush();
                    self.todo.push(function() {
                            next(prev);
                        });
                    var serialNum = ++self.inFlush;
                    setTimeout(function() {
                            if(self.inFlush == serialNum) {
                                self.flush();
                            }
                        }, 0);
                }
                switch (this.state) {
                    case "running":
                        if (breakpoint[n.lineno-1]) { this.doPause(n, x, next, prev) } else {
                            resume();
                        }
                       break;
                    case "step-into":
                        if (n.lineno != this.currentLine) {
                            this.doPause(n, x, next, prev);
                        }
                        else {
                            resume();
                        }
                        break;
                    case "step-over":
                        if (n.lineno != this.currentLine && x.stack.length <= this.stackDepth) {
                            this.doPause(n, x, next, prev);
                        }
                        else {
                            resume();                            
                        }
                        break;
                    case "step-out":
                        if (n.lineno != this.currentLine && x.stack.length < this.stackDepth) {
                            this.doPause(n, x, next, prev);
                        }
                        else {
                            resume();                            
                        }
                        break;
                    case "step-back":
                    case "paused":
                        this.doPause(n, x, next, prev);
                        break;
                    case "stopped":
                        // Don't continue execution.
                        break;
                }
            }
        };
    </script>
</head>

<body bgcolor='#303030'>
<button id="run-button" onclick="tailspinDebugger.run();">Run</button>
<button id="stop-button" onclick="tailspinDebugger.stop();">Stop</button>
<button id="pause-button" onclick="tailspinDebugger.pause();">Pause</button>
<button id="step-over-button" onclick="tailspinDebugger.stepOver();">Step Over</button>
<button id="step-into-button" onclick="tailspinDebugger.stepInto();">Step Into</button>
<button id="step-out-button" onclick="tailspinDebugger.stepOut();">Step Out</button>


<textarea id="source" wrap='off'>
</textarea>
        
<div id="console"></div>

<div id='sourcecode' style='height:0px; overflow:hidden;'>
/** 
 * Algebraic Effects and Handlers as in &lt;a href='http://www.eff-lang.org/'&gt;Eff&lt;/a&gt;
 */

//
// Note:
// new Continuation() - returns the current function's continuation.
//

function callcc(f) {
    return f(new Continuation())
}

/**
 * Implementation of delimited continuation operators given by 
 * &lt;a href='http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.8213'&gt;Filinski&lt;/a&gt;
 */

function MetaContinuation() {

    var metaCont;
    var self = this

    function abort(thunk) {
        var v = thunk();
        var k = metaCont;
        return k(v);
    }

    /**
     * The reset operator sets the limit for the continuation 
     * @param {function} thunk
     */

    this.reset = function(thunk) {
        var saved = metaCont;
        var k = new Continuation();
        metaCont = function(v){
            metaCont = saved;
            var r = k(v);
            return r;
        };
        var r = abort(thunk);
        return r;
    }

    /**
     * The shift operator captures the continuation up to the innermost
     * enclosing reset
     */

    this.shift = function(f) {
        var k = new Continuation();
        var r = abort(function(){
            var r = f(function(v){
                var r = self.reset(function(){
                    var r = k(v);
                    return r;
                });
                return r;
            });
            return r;
        });
        return r;
    }
}

/** Factory to create effects */
function Effects() {

    var metaCont = new MetaContinuation();

    var OPS = {}; // Operation records
    var self = this;

    /**
     * Creates a new Effect
     * @param {string} effect - Name of this effect
     * @returns {Effect}
     */
    this.createEffect = function(effect) {
        return new Effect(effect);
    }

    /** 
     * Factory to create operations and handlers:
     */
    function Effect(effect) {

        /**
         * Creates a new operation.
         * @param {string} name - Name of this operation
         * @returns {function}
         */
        this.createOperation = function(name) {
            var key = effect +"#"+name;
            var op = OPS[key];
            if (undefined == op) {
                op = new Op(name);
                OPS[key] = op;
            }
            var result = function() {
                var args = [];
                for (var i = 0; i &lt; arguments.length; i++) {
                    args.push(arguments[i]);
                }
                // find the handler for this operation and apply it to the arguments of this call together with its continuation
                var h = op.handler();
                var result = metaCont.shift(function(k) {
                    var result = h.call(null, {args: args, k: k});
                    return result;
                });
                return result;
            }
            return result;
        }
        
        /**
         * Creates a new handler
         * @param {object} handlers - an object with function properties which may be 'return', 'finally' or 
         * the names of operations
         * @returns {function}
         */

        this.createHandler = function(handlers) {
            var returnHandler = handlers["return"];
            var finallyHandler = handlers["finally"];
            var ops = [];
            var hs = [];
            for (var opName in handlers) {
                switch (opName) {
                case "return": 
                case "finally": 
                    break;
                default:
                    var h = handlers[opName];
                    var key = effect+"#"+opName;
                    var op = OPS[key];
                    if (undefined == op) {
                        op = new Op(opName);
                        OPS[key] = op;
                    }
                    ops.push(op);
                    hs.push(h);
                }
            }
            return new Handler(returnHandler, finallyHandler, ops, hs);
        }

        // Operation record
        function Op(name) {
            this.name = name;
            this.handler = function() { return function() {throw "no handler: "+effect +"#"+name} }
            this.toString = function() {
                return effect +"#"+name
            }
        }

        // Handler record
        function Handler(returnHandler, finallyHandler, ops, hs) {
            function _return(result) {
                if (undefined != returnHandler) {
                    result = returnHandler(result);
                }
                return result;
            }
            function _finally(result) {
                if (undefined != finallyHandler) {
                    result = finallyHandler(result);
                }
                return result;
            }
            this.handle = function(thunk) {
                var saved = [];
                var finalized = false;
                function installHandler(op, h) {
                    op.handler = function() {
                        return function(opCall) {
                            var returned = false;
                            // operation's arguments
                            var args = opCall.args;
                            // operation's continuation
                            var k = opCall.k;
                            var applyCont = function(v) {
                                // apply the operation's continuation
                                //var result = k(v);
                                var result = k(arguments[0]); // hack: workaround tailspin bug
                                if (!returned) { // return now if we haven't already
                                    result = _return(result);
                                }
                                return result;
                            }
                            var result = h.apply(null, args.concat(applyCont));
                            // fell thru - continuation not called
                            returned = true;
                            if (!finalized) {
                                finalized = true;
                                result = _finally(result);
                            }
                            return result;
                        }
                    }
                }
                // install handlers
                for (var i = 0; i &lt; ops.length; i++) {
                    var op = ops[i];
                    saved.push(op.handler);
                    var h = hs[i];
                    installHandler(op, h);
                }
                // perform handling
                var result = metaCont.reset(function() {
                    var result = thunk();
                    result = _return(result);
                    return result;
                });
                // perform finally
                if (!finalized) {
                    result = _finally(result);
                }
                // restore previous handlers
                for (var i = 0; i &lt; saved.length; i++) {
                    ops[i].handler = saved[i];
                }
                return result;
            }
        }

    }
    this.toString = function() {return "Eff"}
}

function print(x) { console.log(x) }
var exit = new Continuation();

var Eff = new Effects();

// An effect which makes a binary choice
var Choice = Eff.createEffect("choice");

var decide = Choice.createOperation("decide");

function choice() {
    var x = decide() ?  40 : 10;
    var y = decide() ? 0 : 2;
    return x + y;
}

var chooseAll = {
    "return": function(x) { return [x] },
    "decide": function(k) { var xs = k(true); var ys = k(false); return xs.concat(ys); }
}

var h = Choice.createHandler(chooseAll);

print(h.handle(choice)); // prints 40,42,10,12

// Exceptions effect
var Exceptions = Eff.createEffect("exception");

var raise = Exceptions.createOperation("raise");

function Option() {
}

function None() {
    this.prototype = new Option();
    this.getOrElse = function(x) { return x }
    this.toString = function() {return "none"}
}

function Some(x) {
    this.prototype = new Option();
    this.getOrElse = function(_) { return x }
    this.toString = function() {return "some: "+JSON.stringify(x)}
}

var none = new None();

function some(x) { return new Some(x) }

var Exit = Exceptions.createHandler({
    "raise": function(e, k) { print("caught: "+e); exit(); }
});

var Optionalize = Exceptions.createHandler({
    "return": function(v) { return some(v) },
    "raise": function(v, k) { return (none) }
});


var result = Optionalize.handle(function() { return 42 });
print(result); // prints some: 42
result = Optionalize.handle(function() { raise("foo"); return 42 });
print(result); // prints none

// State effect
var State = Eff.createEffect("state");

var get = State.createOperation("get");
var set = State.createOperation("set");


function state(x) {
    return {
        "return": function(v) { return function(s) { return v; } },
        "get": function(k) { return function(s) { return k(s)(s) } },
        "set": function(v, k) { return function(s) { return k()(v) } },
        "finally": function(f) { var r = f(x); return r; }
    };
}

var h = State.createHandler(state(20))
result = h.handle(function()
                  {
                      var q = get();
                      set(q + 11);
                      var q2 = get();
                      return q2;
                  });
print(result); // prints 31



</div>
</body>
</html>
