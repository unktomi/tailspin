<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Tailspin Example - Debugger</title>
    
    <link rel="stylesheet" type="text/css" href="examples.css">
    
    <script id='eff' type="text/javascript" src="Effects.js"></script>
    <script id='eff' type="text/javascript" src="EffectTest.js"></script>
    <script type="text/javascript" src="../tailspin.js"></script>
    
    <script src="lib/codemirror.js"></script>
    <link rel="stylesheet" href="lib/codemirror.css">
    <style type="text/css">
      .breakpoints {width: .8em;}
      .breakpoint { color: #822; }
      .CodeMirror {border: 1px solid #aaa;}
    </style>
    <script src="lib/terminal/js/jquery-1.7.1.min.js"></script>
    <script src="lib/terminal/js/jquery.mousewheel-min.js"></script>
    <script src="lib/terminal/js/jquery.terminal-min.js"></script>
    <link rel="stylesheet" href="lib/terminal/css/jquery.terminal.css">
    <script type="text/javascript">
        var terminal
        var evaluateInContext = function (cmd) {
            if (undefined != cmd) terminal.echo("Not running");
        }
        function initTerm(term) {
            terminal = term;
        }
        var interpreter;
        var tailspinDebugger;
        var mySource, myConsole;
        var breakpoint = {}
        
        window.onload = function() {
            // Create a new interpreter.
            interpreter = new Tailspin.Interpreter();
            tailspinDebugger = new Debugger();
            
            // Add a single global 'console' that has a log function.
            interpreter.global.console = {
                log:function(msg) {consoleLog(msg, 'log');}
            };
            
            mySource = CodeMirror.fromTextArea(document.getElementById("source"),
        {lineNumbers:true, mode:"javascript",  gutters: ["CodeMirror-linenumbers", "breakpoints"]});

mySource.on("gutterClick", function(cm, n) {
  var info = cm.lineInfo(n);
  breakpoint[n] = info.gutterMarkers == null;
  cm.setGutterMarker(n, "breakpoints", !breakpoint[n] ? null : makeMarker());
});

function makeMarker() {
  var marker = document.createElement("div");
  marker.style.color = "#822";
  marker.innerHTML = "●";
  return marker;
}

        var testCode = String(EffectTest);

        var source = MetaContinuation +"\n"+ Effects +"\n{"+testCode.substring(testCode.indexOf("\n"));
        mySource.setValue(source);
//            myConsole = CodeMirror.fromTextArea(document.getElementById("console"),
//                {readOnly:true, mode:"text"});
            
        jQuery(function($, undefined) {
                $('#console').terminal(function(command, term) {
                        initTerm(term);
                        evaluateInContext(command);
                    }, {
                        greetings: 'Evaluate:',
                            name: 'js_demo',
                            height: '30%',
                            history: true,
                            onInit: initTerm,
                            prompt: 'js> '});
            });


            // Save the code on changes.
            mySource.on('change', function(cMirror) {
                localStorage["debugger-source"] = cMirror.getValue();
        });

        

            
            // Load saved code.
            var savedScript = localStorage["debugger-source"];
            if (typeof savedScript === "string") {
                mySource.setValue(savedScript);
            }
        }
        function consoleLog(msg, logClass) {
            terminal.echo(msg)
        }
        
        function Debugger() {
            
            this.state = "stopped";
            this.currentLine = -1;
            this.continuation = null;
            this.highlightedLine = -1;
            
            this.runButton = document.getElementById("run-button");
            this.stopButton = document.getElementById("stop-button");
            this.pauseButton = document.getElementById("pause-button");
            this.stepIntoButton = document.getElementById("step-into-button");
            this.stepOverButton = document.getElementById("step-over-button");
            this.stepOutButton = document.getElementById("step-out-button");
            this.stepBackButton = document.getElementById("step-back-button");
            
           this.updateButtons();
        }
        
        Debugger.prototype = {
            updateButtons: function() {
                var running = (this.state === "paused" || this.state === "stopped");
                
                this.runButton.disabled = !running;
                this.stopButton.disabled = this.state === "stopped";
                this.pauseButton.disabled = running;
                this.stepIntoButton.disabled = !running; // Can start by stepping over or into.
                this.stepOverButton.disabled = !running;
                this.stepOutButton.disabled = this.state !== "paused";
                this.stepBackButton.disabled = this.state !== "paused" || !this.backContinuation;
            },
            end: function(output, outputClass) {
                if (output) {
                    consoleLog(output, outputClass);
                }
                this.state = "stopped";
                this.continuation = null;
                mySource.removeLineClass(this.highlightedLine, 'background', 'current-line');
                this.updateButtons();
            },
            returnFn: function(result) {
                this.end(JSON.stringify(result), "output");
            },
            errorFn: function(result) {
                 this.end("ERROR: "+JSON.stringify(result), "error");
            },
            start: function() {
                // Create an evaluation context that describes the how the code is to be executed.
                var x = interpreter.createExecutionContext();
                
                // Asynchronous running is prefered, so that tailspin execution does not block the browser.
                x.asynchronous = true;
                
                x.control = this.control.bind(this);
                
                this.currentLine = -1;
                this.stackDepth = 0;
                evaluateInContext = function(command) {
                            try {
                                var cx = x.copy();
                                cx.asynchronous = false;
                                var isDone = false;
                                cx.control = function(n, x, next, prev) {
                                    if(!isDone) next(prev)
                                }
                                interpreter.evaluateInContext(command, "", 0, cx, function(result) {
                                      if (undefined != result) terminal.echo(String(result)); isDone = true;
                                 }, function(err) { 
                                      terminal.error(String(err)); isDone = true;
                                }, null)
                            } catch(e) {
                                term.error(new String(e));
                            }
                }
                this.updateButtons();
                
                // Run the code.
                var source = mySource.getValue();
                interpreter.evaluateInContext(source, "source", 0, x, this.returnFn.bind(this), this.errorFn.bind(this), null);
            },
            continueWithState: function(state) {
                this.state = state;
                if (this.continuation) {
                    this.continuation();
                }
                else {
                    this.start();
                }
            },
            run: function() {
                this.continueWithState("running");
            },
            stepInto: function() {
                this.continueWithState("step-into");
            },
            stepOver: function() {
                this.continueWithState("step-over");
            },
            stepOut: function() {
                this.continueWithState("step-out");
            },
            stepBack: function() {
                this.continuation = this.backContinuation;
                this.backContinuation = null;
                this.continueWithState("step-back");
            },
            pause: function() {
                this.state = "paused";
            },
            stop: function() {
                this.state = "stopped";
                this.end();
            },
            
            doPause: function(n, x, next, prev) {
                this.state = "paused";
                this.currentLine = n.lineno;
                this.stackDepth = x.stack.length;
                
                // Save a continuation which will continue the execution of the code.
                this.continuation = function() {
                    this.updateButtons();
                    mySource.removeLineClass(this.highlightedLine, 'background', 'current-line');
                    next(prev);
                  }.bind(this);
                // Save a continuation which will continue the execution of the code.
                this.backContinuation = !prev ? null: function() {
                    this.updateButtons();
                    mySource.removeLineClass(this.highlightedLine, 'background', 'current-line');
                    if (prev) prev();
                  }.bind(this);
                
                // Highlight the new line.
                this.highlightedLine = n.lineno-1;
        mySource.addLineClass(this.highlightedLine, 'background', 'current-line');
        mySource.scrollIntoView({line: this.highlightedLine});
                this.updateButtons();
            },
            
        control: function(n, x, next, prev) {

                switch (this.state) {
                    case "running":
                        if (breakpoint[n.lineno-1]) { this.doPause(n, x, next, prev) } else { next(prev) }
                       break;
                    case "step-into":
                        if (n.lineno != this.currentLine) {
                            this.doPause(n, x, next, prev);
                        }
                        else {
                            next(prev);
                        }
                        break;
                    case "step-over":
                        if (n.lineno != this.currentLine && x.stack.length <= this.stackDepth) {
                            this.doPause(n, x, next, prev);
                        }
                        else {
                            next(prev);
                        }
                        break;
                    case "step-out":
                        if (n.lineno != this.currentLine && x.stack.length < this.stackDepth) {
                            this.doPause(n, x, next, prev);
                        }
                        else {
                            next(prev);
                        }
                        break;
                    case "step-back":
                    case "paused":
                        this.doPause(n, x, next, prev);
                        break;
                    case "stopped":
                        // Don't continue execution.
                        break;
                }
            }
        };
    </script>
</head>

<body bgcolor='#303030'>

<button id="run-button" onclick="tailspinDebugger.run();">Run</button>
<button id="stop-button" onclick="tailspinDebugger.stop();">Stop</button>
<button id="pause-button" onclick="tailspinDebugger.pause();">Pause</button>
<button id="step-over-button" onclick="tailspinDebugger.stepOver();">Step Over</button>
<button id="step-into-button" onclick="tailspinDebugger.stepInto();">Step Into</button>
<button id="step-out-button" onclick="tailspinDebugger.stepOut();">Step Out</button>
<button id="step-back-button" onclick="tailspinDebugger.stepBack();">Step Back</button>

<textarea id="source" wrap='off'>var a = 20;
var b = 5;

function sqr(x) {
    return x*x;
}

a = a * sqr(b);</textarea>
<div id="console"></div>

</body>
</html>
